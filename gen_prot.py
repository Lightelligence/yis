#!/usr/bin/env python
""" Generates Async FIFOs with different edge-sensitivity
Copyright (C) 2019 Lightelligence

"""

################################################################################
# stdlib
import argparse
import os
import sys
from random import getrandbits
import math

# ################################################################################
# Bigger libraries (better to place these later for dependency ordering
import jinja2

################################################################################
# Checkout specific libraries
import cmn_logging

log = None

################################################################################
# Constants

ECC_GEN_TEMPLATE = jinja2.Template(""" {% if docs %}
// DO NOT EDIT!
// This file was automatically generated by {{ script_name }}
// Copyright (c) 2021 Lightelligence
//
// Prot Gen
//
// Description:
//
// Author: Guoqi Lu
{%- endif %}

module {{ module }}(
  output [{{r-1}}:0]  ecc_to_sram,
  input  [{{m-1}}:0]  data_in
);
{%- for ecc_idx_list in ecc[:-1] %}
  assign ecc_to_sram[{{ loop.index - 1 }}]{{ " = "}}
  {%- for idx in ecc_idx_list -%}
    data_in[{{ idx }}]{{ ";\n" if loop.last else "^"}}
  {%- endfor -%}
{%- endfor %}
  assign ecc_to_sram[{{r-1}}] = (^ecc_to_sram[{{r-1-1}}:0]) ^ (^data_in);
endmodule : {{ module }}
""")

ECC_CHK_TEMPLATE = jinja2.Template(""" {% if docs %}
// DO NOT EDIT!
// This file was automatically generated by {{ script_name }}
// Copyright (c) 2021 Lightelligence
//
// Prot CHK
//
// Description:
//
// Author: Guoqi Lu
{%- endif %}

module {{ module }}(
  output  single_bit_err,
  output  double_bit_err,
  output logic [{{m-1}}:0]  data_out,
  input  [{{r-1}}:0]  ecc_from_sram,
  input  [{{m-1}}:0]  data_from_sram
);

  {%- set unused_ecc_bits = 1 -%}
  {%- set tot_unused_bits = unused_ecc_bits -%}
  {%- if tot_unused_bits %}
  wire [{{tot_unused_bits-1}}:0]  unused;
  wire unused_ok;
  assign unused_ok = | unused;
  {%- endif -%}
  {%- set unused_bit = 0 %}

  wire  parity;
  wire [{{r-1-1}}:0]  syndrome;
  wire [{{r-1-1}}:0]  checksum;
  assign syndrome = checksum ^ ecc_from_sram[{{r-1-1}}:0];

  {{ module.replace('chk', 'gen') }} u_ecc (
    .ecc_to_sram({unused[{{unused_bit+unused_ecc_bits-1}}:{{unused_bit}}], checksum}), {%- set unused_bit = unused_bit + unused_ecc_bits %}
    .data_in(data_from_sram)
  );

  {{module.replace('chk', 'gen').replace(m|string +'_ecc', (m+r)|string +'_parity')}} u_parity (
    .parity_to_sram(parity),
    .data_in({ecc_from_sram, data_from_sram})
  );

  //  check syndrome & parity to determine if corruption orackr
  assign single_bit_err = parity;
  assign double_bit_err = (!parity) & (|syndrome);

  //  correct for single bit error
  logic [{{w-1}}:0]  corrupted_bit;
  logic [{{m-1}}:0]  corrupted_1hot;
  always_comb begin
    case(syndrome)
    {%- for corrupted_bit in ecc %}
      {{r-1}}'d{{loop.index % (m+r)}} :  corrupted_bit = {{w}}'d{{corrupted_bit}};
    {%- endfor %}
      default :  corrupted_bit = syndrome;
    endcase
    corrupted_1hot = 1'b1 << corrupted_bit;
    data_out = data_from_sram ^ corrupted_1hot;
  end

  // {{tot_unused_bits}} == {{unused_bit}}

endmodule : {{ module }}
""")

PAR_GEN_TEMPLATE = jinja2.Template(""" {% if docs %}
// DO NOT EDIT!
// This file was automatically generated by {{ script_name }}
// Copyright (c) 2021 Lightelligence
//
// Prot Gen
//
// Description:
//
// Author: Guoqi Lu
{%- endif %}

module {{ module }}(
  output  parity_to_sram,
  input  [{{m-1}}:0]  data_in
);

  assign parity_to_sram = ^data_in;

endmodule : {{ module }}
""")

PAR_CHK_TEMPLATE = jinja2.Template(""" {% if docs %}
// DO NOT EDIT!
// This file was automatically generated by {{ script_name }}
// Copyright (c) 2021 Lightelligence
//
// Prot CHK
//
// Description:
//
// Author: Guoqi Lu
{%- endif %}

module {{ module }}(
  output err,
  output [{{m-1}}:0]  data_out,
  input  parity_from_sram,
  input  [{{m-1}}:0]  data_from_sram
);

  wire parity;
  {{module.replace('chk', 'gen')}} u_parity (
    .parity_to_sram(parity),
    .data_in(data_from_sram)
  );

  assign err = parity ^ parity_from_sram;
  assign data_out = data_from_sram;

endmodule : {{ module }}
""")


def parse_args(argv):
    parser = argparse.ArgumentParser(description="Generates mem protection logic",
                                     formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('--docs-only', default=True, action='store_true', help='only prints the docs header')
    parser.add_argument('--output-file', required=True, help='output filename for SV files')
    parser.add_argument('--prot', default='ecc', choices=['ecc', 'parity', 'none'], help='protection method')
    parser.add_argument('--m', default=4, type=int, help='bit-width of a memory item')
    options = parser.parse_args(argv)
    return options


# helpers


def reverse(l, int2str=False):
    rl = [str(i) if int2str else i for i in l]
    rl.reverse()
    return rl


def l2str(l):
    str_val = str(len(l)) + "'b" + ''.join(reverse(l, True))
    return str_val


def str2bin(data_str):
    import string
    bin_l = []
    bit = len(data_str)
    for i in range(bit):
        c = data_str[bit - i - 1]
        if (c in string.digits):
            if int(c) < 2:
                bin_l.append(int(c))
                continue
        print("Error: - non binary data on bit %0d" % (bit - i - 1))
        exit(1)
    return bin_l


def bin2dec(data_bin):
    data_dec = 0
    for i in range(len(data_bin)):
        data_dec += data_bin[i] * (2**i)
    return data_dec


# calc index for RTL use - hamming coding


def calc_r(m):
    # 2^r >= m + r + 1
    if m < 4:
        raise ValueError(F"m(got {m}) must be >= 4 for meaningful ecc generation")
    for r in range(m):
        if 2**r >= (m + r + 1):
            return r


def calc_hamming_checksum_index(m, r):
    '''
  hamming encoding of checksum
  returns a list of vector, each vector is a list of index used to calculate a particular bit of checksum
  the index here refers to the hamming code (checksum encoded with original data)
  '''
    checksum_index = []
    for p in range(r):
        bits_index = []
        for b in range(2**p - 1, m + r):
            s = str(bin(b + 1))[2:]
            if (s[-1 - p] == "1"):
                bits_index.append(b)
        checksum_index.append(bits_index)
    return checksum_index


def calc_hamming_index(m, r):
    '''
  hamming encoding of data
  returns a list of index of how original data distributed in the hamming code
  '''
    v = [None] * (m + r)
    mm = 0
    rr = m
    for i in range(len(v)):
        j = 0
        while (1):
            if 2**j - 1 == i:
                v[i] = rr
                rr += 1
                break
            elif 2**j - 1 > i:
                v[i] = mm
                mm += 1
                break
            j += 1
    v.append(m + r)
    return v


def calc_ecc_index(m):
    '''
  based off hamming encoding algrithm
  returns a list of vector, each vetor carries index used to calculte each 1 bit of ecc
  it is a wrapper function does similar to hamming encode, but adapt the index pointing to
  index of the origin data
  '''
    r = calc_r(m)
    ecc_index_list = calc_hamming_checksum_index(m, r)
    v = calc_hamming_index(m, r)
    ecc = []
    for ecc_index in ecc_index_list:
        l = ecc_index[1:]
        ecc_bits_index = []
        for b in l:
            ecc_bits_index.append(v[b])
        ecc.append(ecc_bits_index)
    ecc.append(list(range(m + r)))
    return ecc


# for unit test


def calc_parity(data, parity_bit=0):
    for bit in data:
        parity_bit ^= bit
    return parity_bit


def parity_gen(data):
    ''''''
    return [calc_parity(data)]


def parity_chk(value):
    data = value[:-1]
    det = calc_parity(value)
    return data, det


def calc_ecc(data, ecc_idx, ecc_bit=0):
    '''calculate each bit of ecc, by xor
  ecc_idx is a list of index specify which bit to use for calculating ecc
  '''
    for idx in ecc_idx:
        ecc_bit ^= data[idx]
    return ecc_bit


def ecc_gen(data):
    '''gen ecc bits'''
    ecc_index = calc_ecc_index(len(data))
    ecc = [calc_ecc(data, ecc_idx) for ecc_idx in ecc_index[:-1]]
    ecc.append(calc_ecc(data + ecc, ecc_index[-1]))
    return ecc


def ecc_chk(value, m):
    data = value[:m]
    ecc = value[m:]
    r = calc_r(m)
    checksum = []
    for i, b in enumerate(ecc_gen(data)):
        checksum.append(b ^ ecc[i])
    checksum.pop()
    p = calc_parity(value)
    code = bin2dec(checksum)
    err = code > 0
    cor, det = p == 1, (p == 0) and err # cor, det
    v = calc_hamming_index(m, r)
    sym = v[code - 1] if code < (m + r + 1) else code
    if sym < m:
        data[sym] ^= cor
    return data, (cor, det), sym


# unit test
def check(exp, act, msg):
    if exp != act:
        raise ValueError(F"Error: {msg}")


def corrupt(data, corrupts):
    # print("{:>30}".format(l2str(data)))
    for corrupt in corrupts:
        if corrupt is not None:
            data[corrupt] ^= 1
    # print("{:>30}".format(l2str(data)))
    return data


def test_parity_corrupts(data, corrupts):
    exp = str(len(data)) + "'b" + data
    # print("{:>30}".format(exp))
    data = str2bin(data)
    parity = parity_gen(data)
    data += parity
    data = corrupt(data, corrupts)
    data, det = parity_chk(data)
    # print("{:>30}".format(l2str(data)))
    crpts = F"{corrupts}"
    # print(crpts)
    check(det, len(corrupts) > 0, F"detected flag {det} not matching, with {len(corrupts)} corrupts. {crpts}")
    act = l2str(data)
    if not det:
        check(exp, act, F"act {act} not matching exp {exp} - {crpts}")


def test_ecc_corrupts(data, corrupts):
    exp = str(len(data)) + "'b" + data
    # print("{:>30}".format(exp))
    data = str2bin(data)
    m = len(data)
    ecc = ecc_gen(data)
    data += ecc
    data = corrupt(data, corrupts)
    data, (cor, det), sym = ecc_chk(data, m)
    # print("{:>30}".format(l2str(data)))
    crpts = F"{corrupts}"
    # print(crpts)
    check(cor, len(corrupts) == 1, F"corrected flag {cor} not matching, with {len(corrupts)} corrupts. {crpts}")
    check(det, len(corrupts) > 1, F"detected flag {det} not matching, with {len(corrupts)} corrupts. {crpts}")
    if cor:
        check(corrupts[0], sym, F"sym {sym} not matching corrupts {crpts}")
    act = l2str(data)
    if not det:
        check(exp, act, F"act {act} not matching exp {exp} - {crpts}")


def test_parity(data):
    m = len(data)
    s = m + 1
    test_parity_corrupts(data, [])
    for c in range(s):
        test_parity_corrupts(data, [c])


def test_ecc(data):
    m = len(data)
    r = calc_r(m)
    s = m + r + 1
    # print(data)
    test_ecc_corrupts(data, [])
    for c1 in range(s):
        test_ecc_corrupts(data, [c1])
        for c2 in range(c1 + 1, s):
            test_ecc_corrupts(data, [c1, c2])


def ecc_test(m):
    test_ecc(F"{getrandbits(m):0{m}b}")


def parity_test(m):
    test_parity(F"{getrandbits(m):b}")


def unit_test(m):
    ecc_test(m)
    parity_test(m)


def test_ecc_all(m):
    '''full test of all combination of data with all possible corrupts
  a formal verification, but very slow with the increasing of m
  '''
    for i in range(2**3, 2**m):
        test_ecc(F"{i:b}")


# api


def append(filename, module, m, prot, comp):
    gen(filename, module, m, prot, comp, docs=False, file_access_type='a')


def gen(filename, module, m, prot, comp, docs=True, file_access_type='w'):
    '''usually filename matches module name, but in case there is need to
  create a library type file containing modules
  m is width of in data
  prot is within ['ecc', 'parity', 'none']
  comp is either ['gen', 'chk']
  '''
    content = ''
    r = 0
    if prot == 'ecc':
        r = calc_r(m)
        w = math.ceil(math.log(m + r + 1, 2)) # width for pointer selecting data
        if comp == 'gen':
            ecc = calc_ecc_index(m)
            TEMPLATE = ECC_GEN_TEMPLATE
        elif comp == 'chk':
            ecc = calc_hamming_index(m, r)
            TEMPLATE = ECC_CHK_TEMPLATE
        content = TEMPLATE.render(docs=docs,
                                  script_name=__file__.split('/')[-1],
                                  module=module,
                                  m=m,
                                  r=r + 1,
                                  w=w,
                                  ecc=ecc)
    elif prot == 'parity':
        if comp == 'gen':
            TEMPLATE = PAR_GEN_TEMPLATE
        elif comp == 'chk':
            TEMPLATE = PAR_CHK_TEMPLATE
        content = TEMPLATE.render(docs=docs, script_name=__file__.split('/')[-1], module=module, m=m)
    with open(filename, file_access_type) as wfh:
        wfh.write(content)


# main
def main():
    options = parse_args(sys.argv[1:])
    if options.docs_only:
        gen(options.output_file, '', options.m, docs_only=True)


if __name__ == "__main__":
    # main()
    unit_test(7)
