// Copyright (c) {{ year }} Lightelligence
// Description: Memory Wrappers Interface generated from {{ memory.name }}.yis by YIS
{%- set use_qp = 1 -%}
{% for mem in memory.children.values() %}
{% if not mem.gen_deps -%}
{% set global_vars = {} -%}
///////////////////////////////////////////////////////////////////////////////
// name: {{ mem.name }}
// doc_summary: {{ mem.doc_summary }}
{% if mem.doc_verbose -%}
/* doc_verbose: {{ mem.doc_verbose }} */
{%- endif %}
// width: {{ mem.width.equation }}  ==>  {{ mem.width.computed_value }}
// depth: {{ mem.depth.equation }}  ==>  {{ mem.depth.computed_value }}
// ports: {{ mem.ports }}
// prot: {{ mem.prot }}
// sram_cfg: {{mem.sram_cfg}}
// pipe0: {{mem.pipe0}}
// pipe1: {{mem.pipe1}}
// row: {{mem.row}}
// col: {{mem.col}}
// read_ports: {{mem.read_ports}}
// write_ports: {{mem.write_ports}}
// stage0: {{mem.stage0}}

{% if mem.ports == "1p" -%}
    {%- set ports = {'':' wr|rd'} -%}
    {%- set waddr = 'addr' -%}
    {%- set raddr = 'addr' -%}
{%- elif mem.ports == "2p" -%}
    {%- set ports = {'A':'wr', 'B':'rd'} -%}
    {%- set waddr = 'waddr' -%}
    {%- set raddr = 'raddr' -%}
{%- endif -%}
{%- set rports = range(mem.read_ports) -%}
{%- set wports = range(mem.write_ports) -%}
{%- set nports = range(mem.num_ports) -%}

{%- macro init_unused(num_unused_bits) -%}
    {%- set t=global_vars.update({'unused_bit': 0}) %}
    {%- if num_unused_bits -%}
    wire [{{num_unused_bits-1}}:0]  unused;
    wire unused_ok;
    assign unused_ok = |unused;
    {%- endif -%}
{%- endmacro -%}
{%- macro fill_zeros(signal, num_filling_zeros, leading=True) -%}
    {{"{%0d'b0, %s}"|format(num_filling_zeros, signal) if num_filling_zeros else signal}}
{%- endmacro  -%}
{%- macro conn_unused(signal, num_unused_bits, leading=True) -%}
    {{"{unused[%0d:%0d], %s}"|format(global_vars['unused_bit']+num_unused_bits-1,global_vars['unused_bit'], signal) if num_unused_bits else signal }}
    {%- set t=global_vars.update({'unused_bit': global_vars['unused_bit'] + num_unused_bits}) %}
{%- endmacro  -%}
{%- macro suffix(num) -%}
    {{'_%0d'|format(num) if mem.num_ports > 1 else ''}}
{%- endmacro -%}

module {{ mem.module }}(
    {% for nport in nports -%}
        {%- if nport < mem.read_ports -%}
    output [{{mem.dwidth-1}}:0] rdata{{suffix(nport)}},
    input rd{{suffix(nport)}},
            {%- if mem.ports == "2p" %}
    input [{{mem.awidth-1}}:0] raddr{{suffix(nport)}},
            {%- endif %}
        {%- endif %}
        {%- if mem.ports == "1p" %}
    input [{{mem.awidth-1}}:0] addr{{suffix(nport)}},
        {%- endif %}
        {%- if nport < mem.write_ports %}
            {%- if mem.ports == "2p" %}
    input [{{mem.awidth-1}}:0] waddr{{suffix(nport)}},
            {%- endif %}
    input wr{{suffix(nport)}},
    input [{{mem.dwidth-1}}:0] wdata{{suffix(nport)}},
        {%- endif %}
    {% endfor -%}
    // DFT
    input   dft_i_xyz,
    output  dft_o_xyz,
    // prot
    input   prot_i_xyz,
    output  prot_o_xyz,
    input clk
);
    {% set unused_data_bits = mem.col*mem.row*mem.sram.bits-(mem.m+mem.r) if not mem.sram.behav else 0 -%}
    {{ init_unused(unused_data_bits) }}

    typedef struct packed {
    {%- for conn in ports.values() %}
        logic [{{mem.bawidth-1}}:0] {{conn[0].strip()}}addr;
    {%- endfor %}
        logic wr;
        logic [{{mem.m+mem.r-1}}:0] wdata;
        logic rd;
        logic [{{mem.m+mem.r-1}}:0] rdata;
    }   sram_io__st;

    //==========================================================================
    // Write/Read in stages
    //--------------------------------------------------------------------------
    {%- for nport in nports %}
        {%- set signals = [] -%}
        {%- set width = 0 -%}
        {%- if nport < mem.read_ports -%}
            {%- set width = width + 1 -%}
            {{ signals.append("rd") or '' }}
    wire rd_from_inp0{{suffix(nport)}};
            {%- if mem.ports == "2p" -%}
                {%- set width = width + mem.awidth -%}
                {{ signals.append("raddr") or '' }}
    wire [{{mem.awidth-1}}:0] raddr_from_inp0{{suffix(nport)}};
            {%- endif -%}
        {%- endif -%}
        {%- if nport < mem.write_ports -%}
            {%- set width = width + 1 -%}
            {{ signals.append("wr") or '' }}
    wire wr_from_inp0{{suffix(nport)}};
            {%- if mem.ports == "2p" -%}
                {%- set width = width + mem.awidth -%}
                {{ signals.append("waddr") or '' }}
    wire [{{mem.awidth-1}}:0] waddr_from_inp0{{suffix(nport)}};
            {%- endif -%}
        {%- endif -%}
        {%- if mem.ports == "1p" -%}
            {%- set width = width + mem.awidth -%}
            {{ signals.append("addr") or '' }}
    wire [{{mem.awidth-1}}:0] addr_from_inp0{{suffix(nport)}};
        {%- endif %}
    {{mem.pipe_module}} #(.WIDTH({{width}}), .PIPE_STAGES({{mem.stage0}})) addr_in_pipe0{{suffix(nport)}} (
        .d({
        {%- for signal in signals -%}
            {{signal}}{{suffix(nport)}}{{', ' if not loop.last}}
        {%- endfor -%}
            }),
        .q({
        {%- for signal in signals -%}
            {{signal}}_from_inp0{{suffix(nport)}}{{', ' if not loop.last}}
        {%- endfor -%}
            }),
        .clk(clk)
    );
    {%- endfor %}

    {% for wport in wports -%}
    wire [{{mem.m+mem.r-1}}:0] data_to_inp0{{suffix(wport)}};
    wire [{{mem.m+mem.r-1}}:0] data_from_inp0{{suffix(wport)}};
    {{mem.pipe_module}} #(.WIDTH({{mem.m+mem.r}}), .PIPE_STAGES({{mem.stage0}})) data_in_pipe0{{suffix(wport)}} (
        .d(data_to_inp0{{suffix(wport)}}),
        .q(data_from_inp0{{suffix(wport)}}),
        .clk(clk)
    );
    {%- endfor %}

    //==========================================================================
    //  SRAM instance
    //--------------------------------------------------------------------------
    {% if mem.row > 1 -%}
    // addr decoder
        {%- if mem.ports == "1p" %}
    wire [{{mem.row-1}}:0]    addr_decoder[{{mem.num_ports-1}}:0];
            {%- if mem.decoder_rotator -%}
                {%- for nport in nports %}
    assign addr_decoder[{{nport}}] = 1'b1 << addr_from_inp0{{suffix(nport)}}[{{mem.awidth-1}}:{{mem.bawidth}}];
                {%- endfor -%}
            {%- endif -%}
        {%- elif mem.ports == "2p" %}
    wire [{{mem.row-1}}:0]    raddr_decoder[{{mem.read_ports-1}}:0];
    wire [{{mem.row-1}}:0]    waddr_decoder[{{mem.write_ports-1}}:0];
            {%- if mem.decoder_rotator -%}
                {%- for rport in rports %}
    assign raddr_decoder[{{rport}}] = 1'b1 << raddr_from_inp0{{suffix(rport)}}[{{mem.awidth-1}}:{{mem.bawidth}}];
                {%- endfor -%}
                {%- for wport in wports %}
    assign waddr_decoder[{{wport}}] = 1'b1 << waddr_from_inp0{{suffix(wport)}}[{{mem.awidth-1}}:{{mem.bawidth}}];
                {%- endfor -%}
            {%- endif -%}
        {%- endif -%}
    {%- endif %}
    // ctrl bits
    wire [{{mem.row-1}}:0] rd_ctrl;
    wire [{{mem.row-1}}:0] wr_ctrl;
    assign rd_ctrl =
    {%- if mem.row > 1 -%}
        {%- for rport in rports -%}
        ({{raddr}}_decoder[{{rport}}] & { {{mem.row}}{rd_from_inp0{{suffix(rport)}}} }) {{';' if loop.last else '| '}}
        {%- endfor -%}
    {%- else -%}
        rd_from_inp0{{suffix(0)}};
    {%- endif %}
    assign wr_ctrl =
    {%- if mem.row > 1 -%}
        {%- for wport in wports -%}
        ({{waddr}}_decoder[{{wport}}] & { {{mem.row}}{wr_from_inp0{{suffix(wport)}}} }) {{';' if loop.last else '| '}}
        {%- endfor -%}
    {%- else -%}
        wr_from_inp0{{suffix(0)}};
    {%- endif %}

    sram_io__st     sram_io [{{mem.row-1}}:0];

    //  srams
    {%- for row in range(mem.row) %}
    //  io mux
    assign sram_io[{{row}}].rd = rd_ctrl[{{row}}];
    assign sram_io[{{row}}].wr = wr_ctrl[{{row}}];
        {%- if mem.ports == "1p" %}
    assign sram_io[{{row}}].addr =
            {%- if mem.num_ports > 1 -%}
                {%- for nport in nports %}
        addr_decoder[{{nport}}][{{row}}] ? addr_from_inp0{{suffix(nport)}}[{{mem.bawidth-1}}:0] :
                {%- endfor %}
        'x
            {%- else -%}
        addr{{suffix(0)}}[{{mem.bawidth-1}}:0]
            {%- endif -%};
        {%- elif mem.ports == "2p" %}
    assign sram_io[{{row}}].raddr =
            {%- if mem.read_ports > 1 -%}
                {%- for rport in rports %}
        raddr_decoder[{{rport}}][{{row}}] ? raddr_from_inp0{{suffix(rport)}}[{{mem.bawidth-1}}:0] :
                {%- endfor %}
        'x
            {%- else -%}
        raddr{{suffix(0)}}[{{mem.bawidth-1}}:0]
            {%- endif -%};
    assign sram_io[{{row}}].waddr =
            {%- if mem.write_ports > 1 -%}
                {%- for wport in wports %}
        waddr_decoder[{{wport}}][{{row}}] ? waddr_from_inp0{{suffix(wport)}}[{{mem.bawidth-1}}:0] :
                {%- endfor %}
        'x
            {%- else -%}
        waddr{{suffix(0)}}[{{mem.bawidth-1}}:0]
            {%- endif -%};
        {%- endif %}
    assign sram_io[{{row}}].wdata =
        {%- if mem.write_ports > 1 -%}
            {%- for wport in wports %}
        {{waddr}}_decoder[{{wport}}][{{row}}] ? data_from_inp0{{suffix(wport)}} :
            {%- endfor %}
        'x
        {%- else -%}
        data_from_inp0{{suffix(wport)}}
        {%- endif -%};

        {%- for col in range(mem.col) -%}
            {% set col_offset = col*mem.bwidth -%}
            {% set col_delta  = mem.bwidth if (mem.bwidth+col_offset)<=(mem.m+mem.r) else (mem.m+mem.r)-col_offset -%}
    {%- if mem.sram.behav %}
    // behavior mem model
    wire [{{col_delta-1}}:0] data_to_behav_pipe_{{row}}_{{col}};
    {{mem.pipe_module}} #(.WIDTH({{col_delta}}), .PIPE_STAGES({{use_qp}})) u_behav_pipe_{{row}}_{{col}} (
        .d(data_to_behav_pipe_{{row}}_{{col}}),
        .q(sram_io[{{row}}].rdata[{{col_offset+col_delta-1}}:{{col_offset}}]),
        .clk(clk)
    );
    `gumi_{{mem.sram_cfg}} #(.ADDR_WIDTH({{mem.bawidth}}), .DATA_WIDTH({{col_delta}}), .DEPTH({{mem.bdepth}}) ) u_mem_{{row}}_{{col}} (
        .we(sram_io[{{row}}].wr),
        .re(sram_io[{{row}}].rd),
        {% if mem.ports == "1p" -%}
        .waddr(sram_io[{{row}}].addr),
        .raddr(sram_io[{{row}}].addr),
        {% elif mem.ports == "2p" -%}
        .waddr(sram_io[{{row}}].waddr),
        .raddr(sram_io[{{row}}].raddr),
        {% endif -%}
        .wdata(sram_io[{{row}}].wdata[{{col_offset+col_delta-1}}:{{col_offset}}]),
        .rdata(data_to_behav_pipe_{{row}}_{{col}}),
        .clk(clk)
    {%- else %}
    // sram
    `gumi_{{mem.sram_cfg}} u_mem_{{row}}_{{col}} (
        {% set sram_reserve_dp_ports = (mem.ports == "2p") and (mem.sram.sub_family in ['dsl']) -%}
        {% for port, conn in ports.items() -%}
        //  PORT_{{port|upper}}
        //  --
        {% if sram_reserve_dp_ports or 'rd' in ports[port]-%}
        // output
        .Q{{"P" if use_qp}}{{port}}({{conn_unused("sram_io[%0d].rdata[%0d:%0d]"|format(row, col_offset+col_delta-1,col_offset), mem.sram.bits-col_delta) if 'rd' in ports[port]}}),
        // input
        .PIPEME{{port}}({{"'1" if 'rd' in ports[port] else "'0"}}),
        {% endif -%}
        {% if sram_reserve_dp_ports or 'wr' in ports[port] -%}
        // input
        .WE{{port}}({{"sram_io[%0d].wr"|format(row) if mem.ports=="1p" else "'1" if 'wr' in conn else "'0"}}),
        .D{{port}}({{fill_zeros("sram_io[%0d].wdata[%0d:%0d]"|format(row,col_offset+col_delta-1,col_offset), mem.sram.bits-col_delta) if 'wr' in ports[port] else "'0"}}),
        {% endif -%}
        .CLK{{port}}(clk),
        .ME{{port}}(
            {%- for pin in conn.strip().split('|') -%}
            sram_io[{{row}}].{{pin}}{{' | ' if not loop.last}}
            {%- endfor -%}
            ),
        .ADR{{port}}({{fill_zeros("sram_io[%0d].%saddr"|format(row, conn[0].strip()), mem.sram.awidth-mem.bawidth)}}),
        {% endfor -%}
        //  light sleep
        .LS(1'b0)
    {%- endif %}
    );
        {%- endfor -%}
    {%- endfor %}

    //==========================================================================
    // Read out pipeline
    //--------------------------------------------------------------------------
    {% for rport in rports -%}
        {%- if mem.row > 1 %}
    wire [{{mem.awidth-mem.bawidth-1}}:0]   rd_sel{{suffix(rport)}};
    {{mem.pipe_module}} #(.WIDTH({{mem.awidth-mem.bawidth}}), .PIPE_STAGES(1+{{use_qp}})) rd_sel_pipe{{suffix(rport)}} (
        .d({{"r" if mem.ports=="2p" else ""}}addr_from_inp0{{suffix(rport)}}[{{mem.awidth-1}}:{{mem.bawidth}}]),
        .q(rd_sel{{suffix(rport)}}),
        .clk(clk)
    );
        {%- endif %}
    wire [{{mem.m+mem.r-1}}:0] data_from_oup0{{suffix(rport)}};
    {{mem.pipe_module}} #(.WIDTH({{mem.m+mem.r}}), .PIPE_STAGES({{mem.pipe0}}-{{use_qp}})) out_pipe0{{suffix(rport)}} (
        .d(sram_io[{{"rd_sel"+suffix(rport) if mem.row > 1 else "0"}}].rdata),
        .q(data_from_oup0{{suffix(rport)}}),
        .clk(clk)
    );
    wire [{{mem.m-1}}:0] data_to_oup1{{suffix(rport)}};
    {{mem.pipe_module}} #(.WIDTH({{mem.m}}), .PIPE_STAGES({{mem.pipe1}})) out_pipe1{{suffix(rport)}} (
        .d(data_to_oup1{{suffix(rport)}}),
        .q(rdata{{suffix(rport)}}),
        .clk(clk)
    );
    {%- endfor %}

    {% if mem.ecc or mem.parity -%}
    //==========================================================================
    //  Protection
    //--------------------------------------------------------------------------
    //  {{mem.prot|capitalize}}
    //  - gen -
        {%- for wport in wports %}
    wire [{{mem.r-1}}:0] checksum{{suffix(wport)}};
    assign data_to_inp0{{suffix(wport)}} = {checksum{{suffix(wport)}}, wdata{{suffix(wport)}}};
    {{mem.prot_gen_module}} u_gen{{suffix(wport)}} (
        .{{mem.prot}}(checksum{{suffix(wport)}}),
        .data(wdata{{suffix(wport)}})
    );
        {%- endfor %}
    //  - chk -
        {%- for rport in rports %}
    {{mem.prot_chk_module}} u_chk{{suffix(rport)}} (
        .data(data_to_oup1{{suffix(rport)}}),
    {%- if mem.ecc %}
        .single_bit_err(),
        .double_bit_err(),
    {%- endif %}
    {%- if mem.parity %}
        .err(),
    {%- endif %}
        .codeword(data_from_oup0{{suffix(rport)}})
    );
        {%- endfor %}
    //  - hero -

    {% else -%}
        {%- for wport in wports %}
    assign data_to_inp0{{suffix(wport)}} = wdata{{suffix(wport)}};
        {%- endfor -%}
        {%- for rport in rports %}
    assign data_to_oup1{{suffix(rport)}} = data_from_oup0{{suffix(rport)}};
        {%- endfor -%}
    {%- endif %}

endmodule : {{ mem.module }}
{% endif -%}
{% endfor %}
