// Copyright (c) {{ year }} Lightelligence
// Description: FIFO Wrappers Interface generated from {{ blk.name }}.yis by YIS
{% for mem in blk.children.values() %}
{% set global_vars = {} -%}
///////////////////////////////////////////////////////////////////////////////
// name: {{ mem.name }}
// doc_summary: {{ mem.doc_summary }}
/* doc_verbose: {{ mem.doc_verbose }} */
// width: {{ mem.width.equation }}  ==>  {{ mem.width.computed_value }}
// depth: {{ mem.depth.equation }}  ==>  {{ mem.depth.computed_value }}
// ports: {{ mem.ports }}

{% if mem.ports == "1p" -%}
    {%- set ports = {'':' wr|rd'} -%}
    {%- set waddr = 'addr' -%}
    {%- set raddr = 'addr' -%}
{%- elif mem.ports == "2p" -%}
    {%- set ports = {'A':'wr', 'B':'rd'} -%}
    {%- set waddr = 'waddr' -%}
    {%- set raddr = 'raddr' -%}
{%- endif -%}

{%- macro set(key, val) -%}
    {%- set t=global_vars.update({key:val}) -%}
{%- endmacro -%}
{%- macro get(key) -%}
    {{ global_vars[key] }}
{%- endmacro -%}
{%- macro trim(num, pattern="_P", condition=1) -%}
    {{pattern|replace("P", num|string) if condition else ''}}
{%- endmacro -%}
{%- macro array(num, pattern="[P:0]") -%}
    {{trim(num-1, pattern, num-1)}}
{%- endmacro -%}


module {{ mem.name }}_sync_fifo
(
  input  clk,
  input  reset_n,
  input  fifo_wr,
  input  fifo_rd,
  input  [{{ mem.dwidth-1 }}:0] fifo_din,
  //FIXME: plumb this & DFT eventually input mem_pkg::dual_port_test_margin_t dual_port_test_margin,
  output fifo_amt,
  output logic fifo_mt,
  output fifo_afull,
  output fifo_full,
  output fifo_err,
  output logic fifo_rd_vld,
  output logic [{{ mem.dwidth-1 }}:0] fifo_dout
);

  localparam SYNC_RESET_FIXME = 1; // this needs to be reviewed with the reset scheme eventually

  logic [{{ mem.awidth-1 }}:0] waddr;
  logic [{{ mem.awidth-1 }}:0] raddr;
  logic we_n;
  logic pop_req_n;
  logic push_req_n;
{%- if mem.ports == "1p" %}
  // logic [{{ mem.awidth-1 }}:0] addr;

  // simple arb if this is a 1P mem. assertion to go along with it.
  // assign addr = fifo_wr ? waddr : raddr;
  ERR_RW_CONFLICT_ON_SINGLE_PORT_MEM: assert property (@(posedge clk) !(fifo_wr && fifo_rd)) else $error("%t: %m: ERROR: Can't read and write single-port FIFO in the same cycle", $time);

{%- endif %}

  assign push_req_n = ~fifo_wr;
  assign pop_req_n  = ~fifo_rd;

  // err_mode 0 means the error bit is latched until reset on any of the following (refer to the CW_fifoctl_s1_sf module for more details.):
  // 1. Overflow (push and no pop while full).
  // 2. Underflow (pop while empty).
  // 3. Empty pointer mismatch (rd_addr   wr_addr when empty).
  // 4. Full pointer mismatch (rd_addr   wr_addr when full).
  // 5. In between pointer mismatch (rd_addr = wr_addr when neither empty nor full).
  CW_fifoctl_s1_sf #(.depth({{ mem.depth.computed_value }}), .ae_level(1), .af_level(1),
                     .err_mode(0), .rst_mode(SYNC_RESET_FIXME)) fifo_ctrl (  // lint: disable=UNCONN,UNCONO,SYNPRT
    .clk          (clk),
    .rst_n        (reset_n),
    .push_req_n   (push_req_n),
    .pop_req_n    (pop_req_n),
    .diag_n       (1'b1),
    .we_n         (we_n),
    .empty        (fifo_mt),
    .almost_empty (fifo_amt),
    .half_full    (),
    .almost_full  (fifo_afull),
    .full         (fifo_full),
    .error        (fifo_err),
    .wr_addr      (waddr),
    .rd_addr      (raddr));

  {{ mem.module }} fifo_mem (
    .clk(clk),
    .rd(fifo_rd),
    .wr(fifo_wr),
    .waddr(waddr),
    .raddr(raddr),
    .rdata(fifo_dout),
    .wdata(fifo_din),
    .dft_i_xyz(), // FIXME
    .prot_i_xyz(),// FIXME
    .dft_o_xyz(), // FIXME
    .prot_o_xyz() // FIXME
  );

endmodule : {{ mem.name }}_sync_fifo
{% endfor %}
