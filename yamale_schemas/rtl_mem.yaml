doc_summary: include('doc_summary')
doc_verbose: include('doc_verbose', required=False)
memories: list(include('memory'))
---
equation: any(str(min=1), int(min=0))
---
mem_name: str(min=3, exclude='=+!@#$%^&*()-|\/?.,[{]}\`~:;')
doc_verbose: str(min=3)
doc_summary: str(min=3)
memory:
  name: include('mem_name')
  doc_summary: include('doc_summary')
  doc_verbose: include('doc_verbose', required=False)
  width: include('equation')
  depth: include('equation')
  ports: enum('1p', '2p')
  prot: enum('ecc', 'parity', 'none')
  sram_cfg: str(min=35, required=False) # omit this will instantiate a behav model using flop_array_2p
  # -----
  row:  int(min=1, required=False)
  col:  int(min=1, required=False)
  # -----
  read_ports: int(min=1, required=False)
  write_ports: int(min=1, required=False)
  # -----
  # ----- setting pipelines
  pipe0: int(min=1, max=2, required=False) # add flop stages between sram and protection logic: (default 2)
    # 1 - add flop stage at sram output( or use QP instead Q port if sram supports);
    # 2 - add flop stage after rdata muxing - (default)
  pipe1: int(min=0, required=False) # add flop stages between protection logic and io boundary. (default is 1)
  stage0: int(max=1, required=False) # add flop stages between protection logic and sram: (default 0, unless read/write_port > 0)
  sync_fifo: bool(required=False)
